# Statistical Arbitrage Pairs Trading Model v1.4 Description
This script is a four phase statistical arbitrage pairs trading pipeline that takes a matrix of historical prices from `Price_Data.txt` and turns it into a ranked list of “tradable” pairs with backtested trade signals and visual diagnostics. In Phase 1 it loads the raw price matrix (rows are time, columns are assets), then derives log prices and simple log returns (first differences of log prices). It defines helper split functions and prints the resulting shapes, but the core “relevant” dataset it uses for modelling is a fixed window of `data_relevance_period = 90` observations. That 90 period window is what drives the cointegration fitting, the signal threshold optimisation, and the backtest loop length.

In Phase 2 it enumerates every unique asset pair using `itertools.combinations`, then runs an OLS regression in both directions for each pair (A ~ B and B ~ A). For each candidate pair it keeps the direction with the larger absolute slope, treating that slope as the pair’s “cointegration coefficient” and returning an ordered pair (independent, dependent). Using that ordered pair and coefficient, it constructs a residual or “spread” series for each pair as `residual = price_dependent − coefficient * price_independent` (it does not subtract the regression intercept, so the residual is a simplified spread). It then defines the equilibrium level for each spread as its mean, and estimates mean reversion behaviour by counting sign changes of the residual around equilibrium, producing both a crossing frequency and an implied average reversion time in time steps. A pair is deemed tradable only if it clears two filters: reversion frequency above `reversion_frequency_threshold = 0.2`, and a positive cointegration coefficient (so the model stays in the “market neutral long one, short the other” framing used later).

Phase 3 searches for the best entry distance from equilibrium for every tradable pair. It first finds each pair’s maximum absolute deviation from equilibrium, then builds a grid of candidate deviation thresholds from 0 up to that maximum using `deviation_range_intervals = 100`. For every threshold it counts how often the residual breaches the upper band (equilibrium + deviation) or the lower band (equilibrium − deviation), converts those counts into a per side frequency, and plugs that into a profit proxy shaped like `profit = 2 * T * deviation * frequency²`, where `T` is the 90 period window. Because raw breach frequencies can be noisy and not strictly decreasing as the deviation widens, it enforces a strictly decreasing curve by keeping only decreasing points and interpolating back onto the full grid, then applies Tikhonov style smoothing (a second order difference penalty with `regularisation_lambda = 10`). The script recomputes the profit proxy on the smoothed frequencies and chooses the deviation level that maximises it, producing an optimal upper band and lower band around each pair’s equilibrium.

In Phase 4 it runs an event driven backtest across 90 steps while maintaining two dictionaries of open positions: one for “long spread” trades and one for “short spread” trades. A long spread trade opens when the residual drops below the optimised lower band, and closes when it mean reverts back to equilibrium or higher. A short spread trade opens when the residual rises above the optimised upper band, and closes when it falls back to equilibrium or lower. Returns are computed in log space, using a hedge ratio based on the absolute cointegration coefficient so one leg is scaled against the other (long spread returns combine a long in one asset and a scaled short in the other, and vice versa for short spread). It also implements a simple stop loss based on time: if a trade has not reverted within `reversion_time_multiplier * average_reversion_time` (with `reversion_time_multiplier = 2`), it is forcibly closed, recorded as a stop loss event, and the pair is put in a “sin bin” that blocks immediate re entry until the residual crosses back through equilibrium. After looping, it computes a per pair Sharpe style score from the sequence of incremental trade returns using `rf = 0.03`, ranks pairs by that score, and prints the top `number_of_pairs_selected_from_backtest = 5` along with their cumulative return. Finally, it defines a set of plotting utilities to visualise residuals with equilibrium lines, deviation frequency curves before and after smoothing, profit curves, optimised entry bands, and backtest entry and exit markers on both residual plots and side by side raw price charts, plus a short disclaimer block noting that fees and slippage are assumed zero and that only the long/short market neutral style is considered tradable in this version.
